<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-05-01 Tue 14:22 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb27f498">1. Introduction</a></li>
<li><a href="#orge5a069e">2. λ-Calculus</a>
<ul>
<li><a href="#org1a25920">2.1. Fundamental Idea</a></li>
<li><a href="#orgb277b4c">2.2. Arithmetic</a></li>
<li><a href="#org3c59205">2.3. Conditionals</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
We'll take a look at λ-calculus, smallest programming language. We'll try
to look from a mathematical perspective.
</p>

<div id="outline-container-orgb27f498" class="outline-2">
<h2 id="orgb27f498"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Let us start this whole thing with the <i>Hello, World!</i> of C++ template metaprograms,
computing factorials.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">template</span> &lt;<span style="color: #b58900;">int</span> <span style="color: #268bd2;">N</span>&gt; 
<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Factorial</span> {
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = N * <span style="color: #268bd2; font-weight: bold;">Factorial</span>&lt;N-1&gt;::result;
};

<span style="color: #859900; font-weight: bold;">template</span> &lt;&gt; 
<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Factorial</span>&lt;0&gt; {
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = 1;
};
</pre>
</div>

<p>
When you invoke this code with something like <b>Factorial&lt;2&gt;::result</b>, it will expand
as follows
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #268bd2; font-weight: bold;">Factorial</span>&lt;2&gt;::result
2 * <span style="color: #268bd2; font-weight: bold;">Factorial</span>&lt;1&gt;::result
2 * 1 * <span style="color: #268bd2; font-weight: bold;">Factorial</span>&lt;0&gt;::result
2 * 1 * 1
2
</pre>
</div>

<p>
We should explain couple of technical details for this to sink in, if you are
not that good with template mechanism as I am. First notice that we need to use
a static variable. Otherwise, we can only access a member using dot notation like
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #b58900;">my_class</span> <span style="color: #268bd2;">c</span>;
c.my_member = 0;
</pre>
</div>

<p>
This requires us to create the object first, which can only happen while program is
running, ie. runtime. We want to write programs that can be evaluated at compile
time. Thus, we want to be use members that can be associated with the type, not with
an individual object of that type. This is why we use static members. And why const?
</p>

<blockquote>
<p>
Let's say you instantiated the template <br />
<b>Factorial&lt;2&gt;::result</b> <br />
and got to the expansion <br />
<b>2 * 1 * Factorial&lt;0&gt;::result</b>
</p>
</blockquote>

<p>
If we didn't declared result as static const in <b>Factorial&lt;0&gt;</b> specialization, 
compiler would not let us instantiate the result outside of the constructor.
This means compiler would not let us instantiate the member at compile-time
unless it is const. For example, you can do this
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">get_one</span>()
{
    <span style="color: #859900; font-weight: bold;">return</span> 1;
}

<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">One</span> {
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span>;
};

<span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2; font-weight: bold;">One</span>::<span style="color: #268bd2;">result</span> = get_one();
</pre>
</div>

<p>
but you can't do the following. 
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">get_one</span>()
{
    <span style="color: #859900; font-weight: bold;">return</span> 1;
}

<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">One</span> {
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">result</span> = get_one();
};
</pre>
</div>

<p>
Long story short, we use static const variables to force compile-time evaluation
of members.
</p>

<p>
Let's take a look at another example. We can use template metaprogramming to 
encode natural numbers in the style of Peano. Basically, Peano said we can use
0 and a successor function and this is all we need for natural numbers. Here it
is in the code.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Zero</span> 
{
  <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span> = 0;
};

<span style="color: #859900; font-weight: bold;">template</span> &lt;<span style="color: #859900; font-weight: bold;">typename</span> <span style="color: #b58900;">N</span>&gt;
<span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">Succ</span> 
{
  <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">const</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span> = <span style="color: #268bd2; font-weight: bold;">N</span>::value + 1;
};
</pre>
</div>

<p>
Now, <b>Succ&lt;Succ&lt;Zero&gt;&gt;</b> will be evaluated to 2. 
</p>

<div class="remark">
<p>
Peano actually didn't use 0. He was trying to codify math out of sets, as far as
I know, in an attempt to lay solid foundations for mathematics. He said let us start
with empty set, \(\emptyset\). We can define a function, call it <b>succ</b>, that takes a
set and creates another set which has this given set and all its elements flattened
inside.
</p>

<p>
\[\emptyset = 0\]
\[succ(0) = \{ \emptyset \} = 1\]
\[succ(1) = \{ \{ \emptyset \}, \emptyset \} = 2\]
</p>

<p>
Well, I might not be strong on my math history. Peano might not be the one that
first codified natural numbers as sets but this successor idea and constructing
them out of 0, axioms related to this construction etc. are all Peano's work. 
</p>

</div>

<p>
Before diving into lambda calculus implementation, you might want to get your
hands a little bit dirty on template metaprogramming. This is especially advised
if you had real hardship understanding the above examples. A good online text
to learn about it can be found <a href="https://monoinfinito.wordpress.com/series/introduction-to-c-template-metaprogramming/">HERE</a>
</p>


<div id="orgc955d0e" class="figure">
<p><img src="./img/peano.jpg" alt="peano.jpg" />
</p>
<p><span class="figure-number">Figure 1: </span>Guiseppe Peano</p>
</div>

<p>
We'll now ease into implementing lambda calculus.
</p>
</div>
</div>

<div id="outline-container-orge5a069e" class="outline-2">
<h2 id="orge5a069e"><span class="section-number-2">2</span> λ-Calculus</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org1a25920" class="outline-3">
<h3 id="org1a25920"><span class="section-number-3">2.1</span> Fundamental Idea</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Lambda Calculus can be considered as the smallest possible programming language.
It was discovered by Alonzo Church while he was working on class of computable
functions. It can express any computation that a Turing machine can perform.
In Raul Rojas words, <a class='org-ref-reference' href="#Rojas2015">Rojas2015</a>
</p>

<blockquote>
<p>
It is thus equivalent to Turing machines. However, the λ-calculus emphasizes the
use of symbolic transformation rules and does not care about the actual machine 
implementation. It is an approach more related to software than to hardware.
</p>
</blockquote>


<div id="org6752c95" class="figure">
<p><img src="./img/church.jpg" alt="church.jpg" />
</p>
<p><span class="figure-number">Figure 2: </span>Alonzo Church</p>
</div>

<p>
In the simplest case, λ-calculus has two language features; function definition
which we can refer as lambda abstraction and function application. It also uses
a very minimal syntax to express these two. Here is an example where we show the
<b>identity function</b>.
</p>


<div id="orge51b602" class="figure">
<p><img src="./img/identity.jpg" alt="identity.jpg" />
</p>
<p><span class="figure-number">Figure 3: </span>Identity function in λ-Calculus</p>
</div>

<p>
Observe that paranthesis can be avoided by setting up a convention to associate
applications from left to right. With that, we only left with \(\lambda\) and dot as
pieces of our syntax. First part, \(\lambda x\), says we are defining an unnamed 
function that takes a parameter named \(x\). Dot seperates function definition from
its body and what follows dot is the body of a function, which in this case just 
returns the given argument, ie. an identity function. We can apply functions to 
functions as well.
</p>

<p>
\[\lambda x.x \lambda x.x \implies \lambda x.x\]
</p>

<p>
We apply identity function to an identity function in this example. First note
that we omitted paranthesis and things just associate to left. Thus, if we were
to paranthesise things, same could be written as
</p>

<p>
\[(\lambda x.x) \lambda x.x \implies \lambda x.x\]
</p>

<p>
Since identity function returns the argument as is, what we get is identity function
again. 
</p>

<div class="remark">
<p>
Note that we don't have numbers, strings etc. for now. We will take a look into
these things as we go along. But, to make it easier for you to think, here is an
example function that uses numbers.
</p>

<p>
\[(\lambda x. x * x)4 \implies 16\]
</p>

<p>
You can think of that function as a squaring function but in reality, we don't 
have symbols like 4, * in our system yet. We need to learn how to define those
things. The strange things is that you can define all of those fancy computable
things with just these two features of λ-calculus.
</p>

</div>

<p>
One important thing is that names are local to definitions and we need to consider
what it means to be a free or bound variable. 
</p>


<div id="orge7b1b99" class="figure">
<p><img src="./img/freebound.jpg" alt="freebound.jpg" />
</p>
<p><span class="figure-number">Figure 4: </span>Free and Bound variables</p>
</div>

<p>
Look to Raul Rojas' tutorial for more on this issue but I think we can say that a
variable is bound if it is <i>dummy</i> in the sense that we can replace its name with
any other name in a given context and meaning would not change. In a way, they
are already bound to a meaning, they were given meaning before. In the example of
identity function \(\lambda x.x\), you can change \(x\) with \(y,z,w\) etc. and it is 
still the identity function. But, if we have a free variable, it has not a bound
meaning still and things will change according to what meaning we give to it. In
the function \(\lambda x. yx\), y is a free variable. Say we are working with numbers.
If we pass \(2\) as \(y\), we'll have a doubling function but if we pass \(1\), we'll
again have an identity function.
</p>

<div class="remark">
<p>
Functions are anonymous in λ-Calculus but for convenience, we can give them names
when we work with them on paper. For example we can say
</p>

<p>
\[I = \lambda x.x\]
</p>

<p>
to give name \(I\) to identity function. We can show application of this function to
itself by
</p>

<p>
\[II = (\lambda x.x) \lambda x.x \implies \lambda x.x = I\]
</p>

</div>

<p>
It is obvious that most important thing about λ-Calculus is that of how we do term
or name substitution. It is by these substitution mechanisms that we apply an
unnamed function. These are also called <b>reductions</b>. Following example is a little
demanding and we will demonstrate couple of important details related to reductions.
</p>

<p>
Say we have a λ-abstraction given as
</p>

<p>
\[(λx.(λy.xy))y\]
</p>

<p>
and we substitute \(y\) for the bound variable \(x\) in the first λ. We will en up with
λ-term \((λy.yy)\). This is wrong and the problem is a little subtle. In the inner λ, 
\(y\) is a name of both a free and a bound variable. These should not be mixed in a
one λ-term or we will get different results from the same reduction. To see this, 
let's change the name of the bound variable in the inner λ. We can change the names
of bound variables, remember! Let's rename that \(y\) to \(z\). Now we'll have
</p>

<p>
\[(λx.(λz.xz))y\]
</p>

<p>
and now, our result will be \((λz.yz)\). This is clearly different than \((λy.yy)\). If
we apply identity function to both, we'll get \(yI\) from the first and \(II\) from
the second. The procedure is simple though, whenever you have same name for a bound
and a free variable in a λ-term, rename the bound variable before doing any substitution.
</p>

<div class="remark">
<p>
Changing the name of bound variables and keeping the meaning of an expression is
called an α-conversion$.
</p>

</div>

<div class="remark">
<p>
Note that, in a way,
</p>

<p>
\[(λx.(λz.xz))y\]
</p>

<p>
is a function returning a function and we say that we can pass functions as arguments
as well (identity function, remember). Thus, λ-calculus supports higher-order
functions. Also, no name in the terms have an associated type. This is an untyped
language.
</p>

</div>


<p>
Upto this point, things might have sounded a little vague, huh? This is because
we have been using symbols like \(x,y,z \ldots\) that does not refer to anything
in our computational context and this makes many things seem abstract. Now, we 
will start to look into familiar, we'll develop numbers. 
</p>

<p>
We can only define functions in λ-calculus and our nubmers will be functions as
well. Let me just throw you their definitions.
</p>
</div>
</div>

<div id="outline-container-orgb277b4c" class="outline-3">
<h3 id="orgb277b4c"><span class="section-number-3">2.2</span> Arithmetic</h3>
<div class="outline-text-3" id="text-2-2">
<p>
For the last time, before delving into arithmetic, let us recap what we saw. In
our language, we have two semantics; function definition and function application.
We call them λ-abstraction and λ-application. We use very minimal syntax to 
express these features. λ symbol is used to define new unnamed functions and dot
is used to seperate parameters from the body. For application, we just chain
λ-abstractions. In a way, everything is a λ-abstraction in λ-calculus and thus,
everything is a function. 
</p>

<p>
One thing to note is that our functions are actually anonymous. Parameter names
are local and only serve the purpose of term substitution. As an example
</p>

<p>
\[λfx.f(x)\]
</p>

<p>
seems like a function that takes a function and a parameter, then applies given
function to that parameter. Do not let naming conventions fool you. In λ-calculus,
everything is a function. \(x\) is a function as much as \(f\) is a function. You
might be thinking, since we have local names, our functions are momentarily named.
For example;
</p>

<p>
\[(λfx.f(x))λx.xλx.x\]
</p>

<p>
show me passing identity function as both arguments. My arguments are still 
λ-abstractions, unnamed functions. Local names are just there to facilitate name
substitution and term rewriting. 
</p>

<p>
\[(λfx.f(x))λx.xλx.x \implies λx.xλx.x\]
</p>

<p>
When you perform reductions, you will end up with a new λ-abstraction that 
denotes the result of λ-application. Hope things are a little bit more clear
now! Let's move onto arithmetic. 
</p>

<p>
We can only define functions in λ-calculus and our nubmers will be functions as
well. Let me just throw you their definitions.
</p>

<p>
\[λsz.z = 0\]
\[λsz.s(z) = 1\]
\[λsz.s(s(z)) = 2\]
\[λsz.s(s(s(z))) = 3\]
</p>

<p>
and so on. These are called  <b>Church numerals</b> and they are defined this way
by Alonzo Church, again.
</p>

<div class="remark">
<p>
\(λsz.z\) means this function takes two parameters. So it is actually the function
\[λs.(λz.z)\]
It is understood that when we write something like
\[(λabc.aabb)kl\]
</p>

<p>
\(k\) will be substituted for \(a\) and \(l\) for \(b\).
</p>

</div>

<p>
We gave these λ-abstractions names. \(1, 2, 3 \ldots\) are actually names
of our functions just like we said \(I\) names the identity function. These definitions
might seem arbitrary. They are actually modeled after Peano axioms that we mentioned
earlier and satisfy the same properties. Another useful thing about these definitions
is that we can now use them for looping. Say we apply function \(3\) to another
function.
</p>

<p>
\[ 3fa = λsz.s(s(s(z)))fa = f(f(f(a))) \]
</p>

<p>
Say \(f\) is identity function and we apply it to \(y\). We'll get
</p>

<p>
\[λx.x(λx.x(λx.x(y))) = y\]
and this is same as \(3Iy\).
</p>

<div class="remark">
<p>
\(0fa\) expands into \((λsz.z)fa\) which is just \(a\). Thus, applying a function zero
times to an argument leaves the argument unchanged. That is a nice property to
have, right?
</p>

</div>

<p>
So, we have numbers and we named them for our convenience by their usual names. Good!
Let's now define a useful function called <b>successor</b>. From this function, we
expect to get another function and when we give it a number function, we want it
to give us the function representation of next number. Take a look at the
below figure.
</p>


<div id="orge9f9487" class="figure">
<p><img src="./img/successor.jpg" alt="successor.jpg" />
</p>
<p><span class="figure-number">Figure 5: </span>Successor function and successor of 0</p>
</div>

<p>
If you change \(s\) for \(a\) and \(z\) for \(b\), you'll see that this is just the
function \(1\). Pretty neat if you ask me. It is harder to come up with these
abstractions as functions though. That is, and this whole thing, is an aspect
of Church's genius. Take a look at \(S3\) to let whole thing sink in.
</p>

\begin{align}
S3 & = & λnab.a(nab)3 \\
   & = & λab.a(3ab) \\
   & = & λab.a(a(a(a(b)))) \\
   & = & 4 
\end{align}

<p>
We are now ready to define addition of natural numbers and this one is not 
that hard to come up. Addition like \(a + b\) means applying successor function
to \(b\), \(a\) times. For example
</p>

<p>
\[ 2 + 3 = succ(succ(3)) = 5\]
</p>

<p>
and remember that something like \(3 f a\) means applying \(f\) to \(a\) \(3\) times.
With these, you can see that \(a + b = a S b\) which means applying successor
function to \(b\), \(a\) times, as we required. You can think of addition function
as \(λxy.xSy\). This take two arguments and return their addition. Notice here 
again that our language is untyped and it is our responsibility to give
Church numerals as arguments to this function.  
</p>

<p>
For the multiplication, we need to make couple of observations first. First,
show yourself that something like \(2S\) is another function that applies 
successor to its input two times. This is the idea behind <b>currying</b>, named
after the logician Haskell Curry, who also insipred the name of the programming
language Haskell.
</p>

<p>
Currying works by partially applying functions. Take our addition function, 
\(λxy.xSy\). If we only supply one parameter, say 2, we need to evaluate \((λxy.xSy)2\)
which results in \(λy.2Sy\). Thus, \(λy.aSy\) is a function of one parameter that
applies \(S\), \(a\) times to its argument. In a way, \(λy.aSy\) can be named
<b>increment-by-a</b> function. 
</p>


<div id="org496d621" class="figure">
<p><img src="./img/curry.jpg" alt="curry.jpg" />
</p>
<p><span class="figure-number">Figure 6: </span>Haskell Curry</p>
</div>

<div class="remark">
<p>
In mathematics and computer science, <b>currying</b> is the technique of translating the
evaluation of a function that takes multiple arguments (or a tuple of arguments) into 
evaluating a sequence of functions, each with a single argument.
</p>

<p>
In our addition example, addition is
</p>

<p>
\[(λxy.xSy)\] and it can be written as an application of two one-parameter
function, such as
</p>

<p>
\[(λy.(λx.xSy)2)3 = 2 + 3\]
</p>

</div>

<div class="remark">
<p>
This is a nice place to talk about η-conversion. Note that I said \(aS\) is a
function that increments its argument \(a\) times. I also showed this function
as \(λy.aSy\). These two things are equaivalent and reduction from one to other
is called <b>η-conversion</b>. 
</p>

<p>
η-conversion is \(\lambda x.M x \rightsquigarrow M\) when \(M\) does not contain
\(x\) free. In a programming analogy, this corresponds to following two functions.
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #b58900;">T</span> <span style="color: #268bd2;">anonymous</span>-function(<span style="color: #b58900;">T</span> <span style="color: #268bd2;">x</span>){
    M(x)
}
</pre>
</div>

<p>
and we say this is just equal to \(M\). In λ-calculus, a λ-abstraction can only be
applied. This is the only thing you can do with a λ-abstraction. Thus \(λy.aSy\)
can only appear in a program followed by another λ-abstraction, which will be
given as an argument to our function.
</p>

<p>
Say, we want to increment \(x\). We'll write
</p>

<p>
\[(λy.aSy)x = aSx \implies λy.aSy = aS\]
</p>

<p>
This is a little subtle, you need to think and observe on your own a little. 
Now that we know η-conversion, let's learn about two other type of substitutions
while we are at it. We saw <b>α-conversion</b> as well, renaming the bound variables.
</p>

<p>
\[λx.x = λt.t\]
</p>

<p>
Lastly, we have <b>β-reduction</b>, corresponding to function application and substituting
arguments for formal parameters in the body of a function, ie.
\((λx.M)N \rightsquigarrow M[x:=N]\). 
</p>

<p>
Meaning of a λ-abstraction is defined by how the expresssion can be reduced. These
are the three type of reductions that we can apply and there are also equalities
concerning them. For example, if you can reach to one λ-abstraction from other,
through β-reductions, we call them β-equivalent. 
</p>

</div>

<p>
If we apply this increment-by-a function \(b\) times
to \(0\), we'll have
</p>

<p>
\[\underbrace{a + a + \ldots a}_{b\text{ times}}\]
</p>

<p>
which is \(axb\). Thus, we can define multiplication as follows.
</p>

<ul class="org-ul">
<li>\(λx.aSx\) is a function that increments by \(a\)</li>
<li>\(a \times b\) means applying <b>increment-by-a</b> b times to \(0\).</li>
<li>Thus, \(λab.(b (λx.aSx))0\) should give \(a \times b\).</li>
</ul>

<p>
There is another way to define multiplication and it is the preferred way.
This uses an observation related to how we defined numbers. Our numbers
are in the form, if we want to encode integer \(n\)
</p>

<p>
\[\textrm{N}(n) \equiv λfx.\underbrace{f( \ldots f(f x) \ldots)}_{n\text{ applications}}\]
</p>

<p>
and observe that something like \(3(2 f)x\) denotes applying \((2 f)\) \(3\) times to \(x\) which
will expand into applying \(f\) \(6\) times to \(x\). So we can say, 
</p>

<p>
\[m(n f)x = [m \times n] f x\]
</p>

<p>
Thus multiplication can be defined as \(λnmfx.n(m f)x\) which is equivalent to λnmf.n(m f)$
by η-conversion. I now advise you to take couple of small examples like \(3 \times 2\) and
hand-reduce them to their Church numeral representations using both definitions we gave
for multiplication; one using successor function and one using repeated application.
See for yourself that they are equivalent.
</p>
</div>
</div>

<div id="outline-container-org3c59205" class="outline-3">
<h3 id="org3c59205"><span class="section-number-3">2.3</span> Conditionals</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We can encode <i>if-else-then</i> like decision making structures in λ-calculus, similar
to what we did with numbers.  
</p>

<p>
<h1 class='org-ref-bib-h1'>Bibliography</h1>
<ul class='org-ref-bib'><li><a id="Rojas2015">[Rojas2015]</a> Raul Rojas, A Tutorial Introduction to the Lambda Calculus, <i>CoRR</i>, <b>abs/1503.09060</b>, (2015). <a href="http://arxiv.org/abs/1503.09060">link</a>.</li>
</ul>
</p>
</div>
</div>
</div>
</div>
</body>
</html>
