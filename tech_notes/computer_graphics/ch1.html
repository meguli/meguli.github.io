<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-05-01 Tue 14:55 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<p>
In computer graphics, we describe a scene's geometry at a mathematically precise
level and apply algorithms to create digital images of this scene. To specify
scene geometry, we use <b>vectors</b>, <b>points</b> etc. To move these objects around,
we use geometric transformations. We may transform the objects in linear or 
nonlinear ways but all of them will be discretized so that we can approximate 
them on computers. This will bring us to <b>matrices</b>. So, in short, we'll be
talking about linear algebra. Fundamental thing we do in CG, short for computer
graphics, is called <b>digital image synthesis</b>. Imagine an artist looking into
a scene or conjuring up one in her mind, and painting what she sees onto a
canvas. She needs to consider a lot of things; geometric properties of the
objects around, how light comes into the scene, perspectives etc. Keep in 
mind that nature does this all the time: our eyes have retinas that nature
uses as a canvas. Artists simulate this process. Here is the idea behind
digital image synthesis:
</p>

<div class="remark">
<p>
Nature's language is math so there must be a mathematical formulation of this
cast-onto-retina process. If we can f≈ünd this formulation, we can use our
computers to do the same. Note that artists do not exactly simulate the
nature. They add in endless creativity to impress and/or express. But, the
more realistic they want their images to look, the more they need to simulate
the nature. 
</p>

</div>


<div id="org6573f64" class="figure">
<p><img src="./img/analog.jpg" alt="analog.jpg" />
</p>
<p><span class="figure-number">Figure 1: </span>Analog image synthesis with cameras</p>
</div>

<p>
Remember that we actually have an analog way of synthesizing images, analog
cameras! In the figure, you can see the simplest pinhole camera model where
the light coming from the scene is directed to the film where it exposes a
projection of the scene onto the film. This process may guide us in our
computational tasks as well. So in broad terms, we do
</p>

<ol class="org-ol">
<li>Describe the scene geometry in mathematical precision</li>
<li>Project it to the 2D canvas</li>
<li>Describe the light interaction in mathematical precision</li>
<li>Compute the color of each point on the canvas</li>
</ol>

<p>
1 and 2 is termed <b>vertex processing</b>, 3 and 4 is termed <b>lighting &amp; shading</b>. 
There are many ways to achieve these tasks but mathematical and computational
ideas are general enough. We'll focus on general ideas but we'll also try to
show an implementation on the computer so that we can see how all of these 
are realized. We are going to use <b>OpenGL</b> for implementations.
</p>

<p>
A system that brings together different vertex processing, lighting, shading
etc. mechanisms into a coherent whole to implement a digital imaging system
is called a <b>graphics pipeline</b>. We are going to work with programmable 
graphics pipeline offered by OpenGL.
</p>

<div class="remark">
<p>
This is called pipeline because vertex processing, lighting, shading etc.
are implemented in stages that follow each other on real GPUs. This is due
to performance reasons. You can process each point in the geometry seperately
and they can follow the same processing stages independent of each other.
This is a version of SIMD parallelism, Single Instruction Multiple Data.
All this we'll be clear once you get comfortable with programming these
modern GPUs.
</p>

</div>

<p>
We are going to start now, hoping that the big picture is beginning to
form in your mind. As you study, of course, things will get more and more
clear. To be safe, we assume readers had Calculus I, II, III sequence at
least. Advanced Calculus lectures by Theodore Shifrin are available on
Youtube and they are more than enough. In fact, they are amazing. So, let's
continue.
</p>

<p>
Precise study of space, in fact spacetime, is the subject of geometry. For us,
in CG, we try to master the geometry of <b>Euclidean space</b>, \(R^n\), or \(R^3\) most 
of the time. To this end, we dissect underlying structure of \(R^n\). For example,
its rich behaviour under continuous functions is due to its topological nature.
\(R^n\) might show a completely different behaviour due to its linear structure.
As we said, in CG, we are fundamentally concerned with this linear structure.
Linearity might be the most basic thing we can observe in the space around us
and mathematical study of linearity is about <b>vector space</b> structure of \(R^n\).
</p>

<p>
As building blocks of linear geometry, we'll study <b>linear subspaces</b>. There
is nothing more to say about 0-dimensional linear subspace, origin point. 
</p>

<p>
<div id="Defn-1.1"></div>
</p>
<div class="definition">
<p>
<b>Line through origin</b><br />
</p>

<p>
Suppose \(\mathbf{V}\) is a vector space over the field \(\mathbf{F}\) and 
\(\vec{v} \in \mathbf{V}\). A line L through origin is a set of vectors such 
that 
</p>

<p>
\[ L = \{\vec{x} \in \mathbf{V}: \vec{x} = t \vec{v}, t \in \mathbf{F}\} \]
</p>

</div>


<div id="orgd3dd84d" class="figure">
<p><img src="./img/linaff.jpg" alt="linaff.jpg" />
</p>
<p><span class="figure-number">Figure 2: </span>Linear and affine subspaces</p>
</div>

<p>
Take \(R^3\) to be our vector space and \(R\) to be our field. Notice that <b>L</b>
on (I), at the above figure, satisfies vector space axioms and it is contained
in \(R^3\). It is a linear subspace of \(R^3\). On (II), <b>L</b> is again a linear subspace
but <b>A</b> can't be since \(\vec{\emptyset} \notin \mathbf{A}\). We tend to think both of
them as lines but only L, linear structures through origin, is a vector space.
A is called an affine subspace [or a linear variety, linear manifold].
</p>

<p>
<div id="Defn-1.2"></div>
</p>
<div class="definition">
<p>
<b>Affine Subspace</b> <br />
</p>

<p>
Pick an arbitrary \(\vec{w} \in R^n\), the set
</p>

<p>
\[\{ \vec{v} + \vec{w}: \vec{v} \in \mathbf{L} \}\]
</p>

<p>
where L is a linear subspace of \(R^n\) is called an affine subspace.
</p>

</div>

<p>
So A is like a translation of L. We'll talk about linear and affine geometry
later.
</p>

<div class="remark">
<p>
Remember we said we require Advanced Calculus as a prerequisite. This way,
you are accustomed to abstractions like above. If you are a beginner, you might
not be able to see why we devise such abstractions. "Vector space and affine 
space? Both seems like a line to me!", you might think. But if you took
Advanced Calculus, you know the level of clarity abstraction achieves for
us. 
</p>

</div>

<p>
Also important for us are the geometric transformations between these spaces
because that will be how we move the objects around in our scene. To this end,
let us remember the idea of a <b>linear transformation</b>. We use the terms mapping,
transformation, function etc. interchangibly. For a function \(f: X \to Y\), we say
\(X\) is its <b>domain</b> and \(Y\) is its <b>range</b>. 
</p>


<div id="orge251252" class="figure">
<p><img src="./img/mapping.jpg" alt="mapping.jpg" />
</p>
<p><span class="figure-number">Figure 3: </span>Mapping from space X to space Y</p>
</div>

<p>
On the figure, you can see where \(X\) is mapped onto in \(Y\), shaded region. That 
shaded region is called the <b>image</b> of \(f\). If the image of a function is the 
same as its range, we call it an <b>onto</b> function or <b>surjective</b>. This can be
shown as \(\forall y \in Y, \exists x \in X. f(x)=y\), so range is used up in a
sense. We call a function <b>one-to-one</b> or <b>injective</b> if \(f(x_1) = f(x_2)\)
implies \(x_1 = x_2\). This requires no two different elements in the domain
is mapped to same element in the range. If a function is both surjective and
injective, we call it <b>bijective</b>. You can check the figure below, from Wikipedia,
to see the alternatives. 
</p>


<div id="org69b7cba" class="figure">
<p><img src="./img/functions.jpg" alt="functions.jpg" />
</p>
<p><span class="figure-number">Figure 4: </span>Type of functions</p>
</div>

<p>
<div id="Defn-1.3"></div>
</p>
<div class="definition">
<p>
<b>Linear Transformation</b><br />
</p>

<p>
A mapping \(T: X \to Y\) is called a linear transformation if for all \(x_1, x_2 \in X\)
and an arbitrary scalar \(c\), \(T\) satisfies
</p>

<ol class="org-ol">
<li>\(T(x_1 + x_2) = T(x_1) + T(x_2)\)</li>
<li>\(T(c x_1) = cT(x_1)\)</li>
</ol>

</div>

<p>
For us, working on \(R^n\), key thing will be representing these transformations 
as a matrix. We do this by observing that a linear transformation is completely
determined by its effect on basis vectors. In \(R^n\), we can write each vector 
as
</p>

<p>
\[ \vec x = x_1\vec e_1 + x_2\vec e_2 + ... + x_n\vec e_n\]
</p>

<p>
and if we transform this by a linear transformation \(T: R^n \to R^m\), we get
</p>

<p>
\[ T(\vec{x}) = x_1T(\vec{e_1}) + x_2T(\vec{e_2}) + ... + x_nT(\vec{e_n}) \]
</p>

<p>
by definition of linearity. Now, \(x_1, x_2, ... x_n\) are coordinates and they 
are scalar. So if we write these coordinates as a column vector, we can get
to the above affect as a matrix multiplication as shown on the below figure.
</p>


<div id="org24c0338" class="figure">
<p><img src="./img/lin_matrix.jpg" alt="lin_matrix.jpg" />
</p>
<p><span class="figure-number">Figure 5: </span>Linear transformations as matrices</p>
</div>

<p>
\(T(\vec{e_1}), T(\vec{e_2})... T(\vec{e_n})\) will be elements of \(R^m\) since \(T\)
maps from \(R^n\) to \(R^m\). This means we will have \(m\) elements in each column, 
giving us \(m\) rows. We will have \(n\) columns for each basis of \(R^n\). Thus a 
mapping from \(R^n\) to \(R^m\) will be represented by an \(mxn\) matrix. Now, let
us talk about an example linear transformation, reflection. 
</p>


<div id="org36ba30f" class="figure">
<p><img src="./img/reflection.jpg" alt="reflection.jpg" />
</p>
<p><span class="figure-number">Figure 6: </span>Reflection as a linear transformation</p>
</div>

<p>
The matrix we use for such a tranformation will be developed later. For now, 
just observe the linear nature of reflection. Also, take a notice of the part
\(R_v(\vec w) = \vec w\). This should remind you of eigenvalues and eigenvectors.
</p>

<div class="definition">
<p>
<b>Eigenvalues, Eigenvectors</b><br />
</p>

<p>
For a linear transformation \(T\), if a vector \(\vec v\) and scalar \(\lambda\) satisfies
\(T(\vec v) = \lambda \vec v\), we call \(\vec v\) an eigenvector and \(\lambda\) an
eigenvalue. 
</p>

</div>

<p>
This might seem arbitrary but believe me, disecting these are the
most useful analysis you can perform on a linear transformation.We are interested
in analyzing the <b>eigenspace</b>. Eigenvectors also form a vector space and this is
called eigenspace. The basis of eigenspace of a linear transformation says so much
about the transformation itself. In CG, we won't use them much at the beginning but
any advanced study of CG requires their mastery. 
</p>

<p>
Let's now take a look at this affine thing. I can tell you, as an example, that
translation is an affine transformation. Trust me at the beginning and we will
show that it is indeed not a linear transformation. Suppose translation is a 
linear transformation, denote it \(T\). Also say, \(X\) is a vector space. Being a
linear transformation, \(T\) should map \(X\) to a vector space because linear maps
preserve vector space structure, ie. homomorphism for vector spaces. Call the
range of \(T\) as \(Y\). Again, if \(T\) is linear, \(Y\) must be a vector space. 
</p>


<p>
<div id="Thm-1.1"></div>
</p>
<div class="theorem">
<p>
Translation is not a linear transformation.
</p>

</div>

<div class="proof">
<p>
Suppose we are translating by a vector \(\vec w\). Thus we can say
</p>

<p>
\[Y = {X + \vec w}\] for all \(\vec x \in X\). If \(\vec w\) is not \(0\), in which
case we would not be translating anyways, \(X\) and \(Y\) can't have any intersection.
Suppose \(\vec k \in X, Y\). Then \(\vec k - \vec w \in X\). This means 
\(\vec k - ( \vec k - \vec w ) = \vec w \in X\). But if \(\vec w\) is contained in
\(X\) we would not be translating because all point would still be remain in \(X\)
after translation. Thus, again, \(X\) and \(Y\) can't have any intersection.
Remember, \(\vec \emptyset \in X\). Thus \(Y\) can't contain the origin vector.
This defies the vector space axioms. Thus, \(Y\) can't be a vector space. By
contrapositive of if \(T\) is linear, \(Y\) is a vector space, we can say \(T\) is
not linear. 
</p>

</div>

<p>
Ok, it is not linear. But is it affine? What is an affine mapping? What kind of
structure it preserves? Can we represent them as matrices as well? These questions
will be answered in detail later. We, as you can guess, assume a maturity in linear
algebra but affine spaces might be unheard of to many. We will develop them in detail.
Let's, for now, accept that we will use transformations to move objects around and
affine transformations preserve the flatness of a space. For example, if you apply
an affine transformation to a triangle, it will still be a triangle in the new
space because affine transformations preserve straightness, paralellness etc. of
lines. Again, all of this will be clear later.
</p>

<p>
How we are going to use these mathematical models to realize imaging algorithms on a
real computer, we should understand that as well. We are trying to visualize surfaces
of the objects in a scene but in a real world scene, there might be very complex 
shapes. Our strategy is to approximate these curved, rich surfaces by using many
small flat, linear surfaces. The figure below may help you visualize this strategy.
</p>


<div id="org5ad381b" class="figure">
<p><img src="./img/bunny.jpg" alt="bunny.jpg" />
</p>
<p><span class="figure-number">Figure 7: </span>A bunny is better and better approximated by more triangles patched together</p>
</div>

<p>
Many triangles patched together in order to approximate a surface is called a <b>mesh</b>,
in this case a <b>triangle mesh</b> because we can use other geometric objects to approximate
a surface. You can see a point on the least-detailed mesh on the above figure, called
<b>v1</b>. This is a <b>vertex</b> on the mesh. It is in 3D world and has coordinates \(x, y, z\).
A triangle is made of three vertices and each triangle is called a <b>face</b>. In a graphics
pipeline, we process these vertices and faces to our application's needs. Without putting
them into a structure, same points may end up representing a different shape then bunny. 
This object we are trying to visualize is called our <b>model</b> and processing the data
that belongs to a model is crucial for realistically and efficiently visualizing the 
model. All computations related to modeling is performed in a stage called <b>vertex</b>
<b>processing</b> and in a real graphics pipeline, it might be implemented as many substages.
For example, in vertex processing stage, we might interpolate the normals for each
face, we might move the object far away from camera using matrices etc.
</p>

<p>
Output of vertex processing stage might be called a <b>fragment</b>, or pixel depending on
used terminology. These are candidates to be visualized in the final image. Not all of
them ends up on the image because we do some processing to eliminate unneeded ones. 
For example, one fragment might lie behind the other and may represent something that
is not visible in the scene in the first place, due to being obscured by another object.
These will be, of course, eliminated from the final digital image as well. For the
ones remaining, we calculate the color of the fragment. This stage of the graphics
pipeline is called <b>ligthing and shading</b>. This could, again, be implemented as many
substages on a real graphics pipeline. 
</p>

<p>
This is, of course, a crude way to look at graphics pipelines and we will give more
detail as we go along. Still, the output image for the above bunny might look something
like this.
</p>


<div id="orged3eadb" class="figure">
<p><img src="./img/bunny_colored.jpg" alt="bunny_colored.jpg" />
</p>
<p><span class="figure-number">Figure 8: </span>A bunny after we performed shading and coloring</p>
</div>

<p>
Meshes are not the only way to approximate arbitrary curves and surfaces. There
are many methods in fact. Meshes are popular because modern GPUs can process
them very efficiently but in an advanced study of CG, we need to know many
other techniques. One such technique depends on <b>polynomial approximations</b>
and we will talk about it briefly here so that you can have an idea. 
</p>


<div id="org2dda066" class="figure">
<p><img src="./img/bernstein.jpg" alt="bernstein.jpg" />
</p>
<p><span class="figure-number">Figure 9: </span>Bernstein polynomial approximating a parabola</p>
</div>

<p>
Above formula might seem remote at first, we will talk about it in detail later. 
For now, try to see the big picture. Here, we have three points \(P_1, P_2, P_3\).
These are the <b>control points</b> of our curve. Note that formula gives the point
\(P_1\) when \(t=0\) and \(P_3\) when \(t=1\). In between 0 and 1, we get a point on the
curve \(C\) for each \(t\) value. We store three points and evaluate these formulas
in as much detail as we want to approximate a smooth curve. This is again a
good way to discretize a continuous phenomenon. Bezier curves and surfaces, NURBS,
splines etc. methods all work with this basic principle. We'll also take a look
at those since they are used heavily in modeling.
</p>

<p>
In this introduction, we wanted to give an idea of what CG really is, what we
do, what are some mathematical techniques we'll be employing etc. This whirlwind
tour was meant to whet your apetite but also to make sure you are up-to-date
with mathematical prerequisites. We also require that you know C++ programming.
If you are satisfied with this chapter and nothing seems useless or esoteric,
you can follow with next chapter to start learning more. 
</p>
</div>
</body>
</html>
