<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-05-01 Tue 14:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Notes for Computer Graphics</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Burak Kaan Copur" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../orgcss/org.css"/>

<script type="text/javascript" src="https://orgmode.org/org-info.js">
/**
 *
 * @source: https://orgmode.org/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in https://orgmode.org/org-info.js.
 *
 * Copyright (C) 2012-2018 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in https://orgmode.org/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "5em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "Neo-Euler"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "Neo-Euler"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "left",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Notes for Computer Graphics</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8ebc9cc">1. Introduction</a></li>
<li><a href="#org5677c25">2. Some Geometry for Computer Graphics</a>
<ul>
<li><a href="#org080ae90">2.1. Affine Spaces and Transformations</a></li>
</ul>
</li>
<li><a href="#org5d9fd3d">3. OpenGL Graphics Pipeline</a></li>
<li><a href="#orga86eb85">4. A Sample OpenGL Program</a></li>
<li><a href="#org6cbc86f">5. OpenGL Data, aka Models</a></li>
<li><a href="#org5884b14">6. OpenGL Algorithms, aka Shaders</a></li>
<li><a href="#org13ecc27">7. Project | Deferred Rendering</a></li>
<li><a href="#org17e6bf9">8. A Bag of Advanced Rendering Techniques</a></li>
<li><a href="#orgb485e7e">9. Rendering Equation</a></li>
<li><a href="#org4b9799a">10. Ray Tracing I</a></li>
<li><a href="#orgfdccf86">11. Ray Tracing II</a></li>
<li><a href="#org2d0d3c8">12. Ray Tracing III</a></li>
</ul>
</div>
</div>
<p>
\blankpage
</p>

<div id="outline-container-org8ebc9cc" class="outline-2">
<h2 id="org8ebc9cc"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
In computer graphics, we describe a scene's geometry at a mathematically precise
level and apply algorithms to create digital images of this scene. To specify
scene geometry, we use <b>vectors</b>, <b>points</b> etc. To move these objects around,
we use geometric transformations. We may transform the objects in linear or 
nonlinear ways but all of them will be discretized so that we can approximate 
them on computers. This will bring us to <b>matrices</b>. So, in short, we'll be
talking about linear algebra. Fundamental thing we do in CG, short for computer
graphics, is called <b>digital image synthesis</b>. Imagine an artist looking into
a scene or conjuring up one in her mind, and painting what she sees onto a
canvas. She needs to consider a lot of things; geometric properties of the
objects around, how light comes into the scene, perspectives etc. Keep in 
mind that nature does this all the time: our eyes have retinas that nature
uses as a canvas. Artists simulate this process. Here is the idea behind
digital image synthesis:
</p>

<div class="remark">
<p>
Nature's language is math so there must be a mathematical formulation of this
cast-onto-retina process. If we can f≈ünd this formulation, we can use our
computers to do the same. Note that artists do not exactly simulate the
nature. They add in endless creativity to impress and/or express. But, the
more realistic they want their images to look, the more they need to simulate
the nature. 
</p>

</div>


<div id="orga6431af" class="figure">
<p><img src="./img/analog.jpg" alt="analog.jpg" />
</p>
<p><span class="figure-number">Figure 1: </span>Analog image synthesis with cameras</p>
</div>

<p>
Remember that we actually have an analog way of synthesizing images, analog
cameras! In the figure, you can see the simplest pinhole camera model where
the light coming from the scene is directed to the film where it exposes a
projection of the scene onto the film. This process may guide us in our
computational tasks as well. So in broad terms, we do
</p>

<ol class="org-ol">
<li>Describe the scene geometry in mathematical precision</li>
<li>Project it to the 2D canvas</li>
<li>Describe the light interaction in mathematical precision</li>
<li>Compute the color of each point on the canvas</li>
</ol>

<p>
1 and 2 is termed <b>vertex processing</b>, 3 and 4 is termed <b>lighting &amp; shading</b>. 
There are many ways to achieve these tasks but mathematical and computational
ideas are general enough. We'll focus on general ideas but we'll also try to
show an implementation on the computer so that we can see how all of these 
are realized. We are going to use <b>OpenGL</b> for implementations.
</p>

<p>
A system that brings together different vertex processing, lighting, shading
etc. mechanisms into a coherent whole to implement a digital imaging system
is called a <b>graphics pipeline</b>. We are going to work with programmable 
graphics pipeline offered by OpenGL.
</p>

<div class="remark">
<p>
This is called pipeline because vertex processing, lighting, shading etc.
are implemented in stages that follow each other on real GPUs. This is due
to performance reasons. You can process each point in the geometry seperately
and they can follow the same processing stages independent of each other.
This is a version of SIMD parallelism, Single Instruction Multiple Data.
All this we'll be clear once you get comfortable with programming these
modern GPUs.
</p>

</div>

<p>
We are going to start now, hoping that the big picture is beginning to
form in your mind. As you study, of course, things will get more and more
clear. To be safe, we assume readers had Calculus I, II, III sequence at
least. Advanced Calculus lectures by Theodore Shifrin are available on
Youtube and they are more than enough. In fact, they are amazing. So, let's
continue.
</p>

<p>
Precise study of space, in fact spacetime, is the subject of geometry. For us,
in CG, we try to master the geometry of <b>Euclidean space</b>, \(R^n\), or \(R^3\) most 
of the time. To this end, we dissect underlying structure of \(R^n\). For example,
its rich behaviour under continuous functions is due to its topological nature.
\(R^n\) might show a completely different behaviour due to its linear structure.
As we said, in CG, we are fundamentally concerned with this linear structure.
Linearity might be the most basic thing we can observe in the space around us
and mathematical study of linearity is about <b>vector space</b> structure of \(R^n\).
</p>

<p>
As building blocks of linear geometry, we'll study <b>linear subspaces</b>. There
is nothing more to say about 0-dimensional linear subspace, origin point. 
</p>

<p>
<div id="Defn-1.1"></div>
</p>
<div class="definition">
<p>
<b>Line through origin</b><br />
</p>

<p>
Suppose \(\mathbf{V}\) is a vector space over the field \(\mathbf{F}\) and 
\(\vec{v} \in \mathbf{V}\). A line L through origin is a set of vectors such 
that 
</p>

<p>
\[ L = \{\vec{x} \in \mathbf{V}: \vec{x} = t \vec{v}, t \in \mathbf{F}\} \]
</p>

</div>


<div id="org71abc3b" class="figure">
<p><img src="./img/linaff.jpg" alt="linaff.jpg" />
</p>
<p><span class="figure-number">Figure 2: </span>Linear and affine subspaces</p>
</div>

<p>
Take \(R^3\) to be our vector space and \(R\) to be our field. Notice that <b>L</b>
on (I), at the above figure, satisfies vector space axioms and it is contained
in \(R^3\). It is a linear subspace of \(R^3\). On (II), <b>L</b> is again a linear subspace
but <b>A</b> can't be since \(\vec{\emptyset} \notin \mathbf{A}\). We tend to think both of
them as lines but only L, linear structures through origin, is a vector space.
A is called an affine subspace [or a linear variety, linear manifold].
</p>

<p>
<div id="Defn-1.2"></div>
</p>
<div class="definition">
<p>
<b>Affine Subspace</b> <br />
</p>

<p>
Pick an arbitrary \(\vec{w} \in R^n\), the set
</p>

<p>
\[\{ \vec{v} + \vec{w}: \vec{v} \in \mathbf{L} \}\]
</p>

<p>
where L is a linear subspace of \(R^n\) is called an affine subspace.
</p>

</div>

<p>
So A is like a translation of L. We'll talk about linear and affine geometry
later.
</p>

<div class="remark">
<p>
Remember we said we require Advanced Calculus as a prerequisite. This way,
you are accustomed to abstractions like above. If you are a beginner, you might
not be able to see why we devise such abstractions. "Vector space and affine 
space? Both seems like a line to me!", you might think. But if you took
Advanced Calculus, you know the level of clarity abstraction achieves for
us. 
</p>

</div>

<p>
Also important for us are the geometric transformations between these spaces
because that will be how we move the objects around in our scene. To this end,
let us remember the idea of a <b>linear transformation</b>. We use the terms mapping,
transformation, function etc. interchangibly. For a function \(f: X \to Y\), we say
\(X\) is its <b>domain</b> and \(Y\) is its <b>range</b>. 
</p>


<div id="org334ee4e" class="figure">
<p><img src="./img/mapping.jpg" alt="mapping.jpg" />
</p>
<p><span class="figure-number">Figure 3: </span>Mapping from space X to space Y</p>
</div>

<p>
On the figure, you can see where \(X\) is mapped onto in \(Y\), shaded region. That 
shaded region is called the <b>image</b> of \(f\). If the image of a function is the 
same as its range, we call it an <b>onto</b> function or <b>surjective</b>. This can be
shown as \(\forall y \in Y, \exists x \in X. f(x)=y\), so range is used up in a
sense. We call a function <b>one-to-one</b> or <b>injective</b> if \(f(x_1) = f(x_2)\)
implies \(x_1 = x_2\). This requires no two different elements in the domain
is mapped to same element in the range. If a function is both surjective and
injective, we call it <b>bijective</b>. You can check the figure below, from Wikipedia,
to see the alternatives. 
</p>


<div id="org145755f" class="figure">
<p><img src="./img/functions.jpg" alt="functions.jpg" />
</p>
<p><span class="figure-number">Figure 4: </span>Type of functions</p>
</div>

<p>
<div id="Defn-1.3"></div>
</p>
<div class="definition">
<p>
<b>Linear Transformation</b><br />
</p>

<p>
A mapping \(T: X \to Y\) is called a linear transformation if for all \(x_1, x_2 \in X\)
and an arbitrary scalar \(c\), \(T\) satisfies
</p>

<ol class="org-ol">
<li>\(T(x_1 + x_2) = T(x_1) + T(x_2)\)</li>
<li>\(T(c x_1) = cT(x_1)\)</li>
</ol>

</div>

<p>
For us, working on \(R^n\), key thing will be representing these transformations 
as a matrix. We do this by observing that a linear transformation is completely
determined by its effect on basis vectors. In \(R^n\), we can write each vector 
as
</p>

<p>
\[ \vec x = x_1\vec e_1 + x_2\vec e_2 + ... + x_n\vec e_n\]
</p>

<p>
and if we transform this by a linear transformation \(T: R^n \to R^m\), we get
</p>

<p>
\[ T(\vec{x}) = x_1T(\vec{e_1}) + x_2T(\vec{e_2}) + ... + x_nT(\vec{e_n}) \]
</p>

<p>
by definition of linearity. Now, \(x_1, x_2, ... x_n\) are coordinates and they 
are scalar. So if we write these coordinates as a column vector, we can get
to the above affect as a matrix multiplication as shown on the below figure.
</p>


<div id="org9fb9565" class="figure">
<p><img src="./img/lin_matrix.jpg" alt="lin_matrix.jpg" />
</p>
<p><span class="figure-number">Figure 5: </span>Linear transformations as matrices</p>
</div>

<p>
\(T(\vec{e_1}), T(\vec{e_2})... T(\vec{e_n})\) will be elements of \(R^m\) since \(T\)
maps from \(R^n\) to \(R^m\). This means we will have \(m\) elements in each column, 
giving us \(m\) rows. We will have \(n\) columns for each basis of \(R^n\). Thus a 
mapping from \(R^n\) to \(R^m\) will be represented by an \(mxn\) matrix. Now, let
us talk about an example linear transformation, reflection. 
</p>


<div id="orga51f534" class="figure">
<p><img src="./img/reflection.jpg" alt="reflection.jpg" />
</p>
<p><span class="figure-number">Figure 6: </span>Reflection as a linear transformation</p>
</div>

<p>
The matrix we use for such a tranformation will be developed later. For now, 
just observe the linear nature of reflection. Also, take a notice of the part
\(R_v(\vec w) = \vec w\). This should remind you of eigenvalues and eigenvectors.
</p>

<div class="definition">
<p>
<b>Eigenvalues, Eigenvectors</b><br />
</p>

<p>
For a linear transformation \(T\), if a vector \(\vec v\) and scalar \(\lambda\) satisfies
\(T(\vec v) = \lambda \vec v\), we call \(\vec v\) an eigenvector and \(\lambda\) an
eigenvalue. 
</p>

</div>

<p>
This might seem arbitrary but believe me, disecting these are the
most useful analysis you can perform on a linear transformation.We are interested
in analyzing the <b>eigenspace</b>. Eigenvectors also form a vector space and this is
called eigenspace. The basis of eigenspace of a linear transformation says so much
about the transformation itself. In CG, we won't use them much at the beginning but
any advanced study of CG requires their mastery. 
</p>

<p>
Let's now take a look at this affine thing. I can tell you, as an example, that
translation is an affine transformation. Trust me at the beginning and we will
show that it is indeed not a linear transformation. Suppose translation is a 
linear transformation, denote it \(T\). Also say, \(X\) is a vector space. Being a
linear transformation, \(T\) should map \(X\) to a vector space because linear maps
preserve vector space structure, ie. homomorphism for vector spaces. Call the
range of \(T\) as \(Y\). Again, if \(T\) is linear, \(Y\) must be a vector space. 
</p>


<p>
<div id="Thm-1.1"></div>
</p>
<div class="theorem">
<p>
Translation is not a linear transformation.
</p>

</div>

<div class="proof">
<p>
Suppose we are translating by a vector \(\vec w\). Thus we can say
</p>

<p>
\[Y = {X + \vec w}\] for all \(\vec x \in X\). If \(\vec w\) is not \(0\), in which
case we would not be translating anyways, \(X\) and \(Y\) can't have any intersection.
Suppose \(\vec k \in X, Y\). Then \(\vec k - \vec w \in X\). This means 
\(\vec k - ( \vec k - \vec w ) = \vec w \in X\). But if \(\vec w\) is contained in
\(X\) we would not be translating because all point would still be remain in \(X\)
after translation. Thus, again, \(X\) and \(Y\) can't have any intersection.
Remember, \(\vec \emptyset \in X\). Thus \(Y\) can't contain the origin vector.
This defies the vector space axioms. Thus, \(Y\) can't be a vector space. By
contrapositive of if \(T\) is linear, \(Y\) is a vector space, we can say \(T\) is
not linear. 
</p>

</div>

<p>
Ok, it is not linear. But is it affine? What is an affine mapping? What kind of
structure it preserves? Can we represent them as matrices as well? These questions
will be answered in detail later. We, as you can guess, assume a maturity in linear
algebra but affine spaces might be unheard of to many. We will develop them in detail.
Let's, for now, accept that we will use transformations to move objects around and
affine transformations preserve the flatness of a space. For example, if you apply
an affine transformation to a triangle, it will still be a triangle in the new
space because affine transformations preserve straightness, paralellness etc. of
lines. Again, all of this will be clear later.
</p>

<p>
How we are going to use these mathematical models to realize imaging algorithms on a
real computer, we should understand that as well. We are trying to visualize surfaces
of the objects in a scene but in a real world scene, there might be very complex 
shapes. Our strategy is to approximate these curved, rich surfaces by using many
small flat, linear surfaces. The figure below may help you visualize this strategy.
</p>


<div id="org620ba2b" class="figure">
<p><img src="./img/bunny.jpg" alt="bunny.jpg" />
</p>
<p><span class="figure-number">Figure 7: </span>A bunny is better and better approximated by more triangles patched together</p>
</div>

<p>
Many triangles patched together in order to approximate a surface is called a <b>mesh</b>,
in this case a <b>triangle mesh</b> because we can use other geometric objects to approximate
a surface. You can see a point on the least-detailed mesh on the above figure, called
<b>v1</b>. This is a <b>vertex</b> on the mesh. It is in 3D world and has coordinates \(x, y, z\).
A triangle is made of three vertices and each triangle is called a <b>face</b>. In a graphics
pipeline, we process these vertices and faces to our application's needs. Without putting
them into a structure, same points may end up representing a different shape then bunny. 
This object we are trying to visualize is called our <b>model</b> and processing the data
that belongs to a model is crucial for realistically and efficiently visualizing the 
model. All computations related to modeling is performed in a stage called <b>vertex</b>
<b>processing</b> and in a real graphics pipeline, it might be implemented as many substages.
For example, in vertex processing stage, we might interpolate the normals for each
face, we might move the object far away from camera using matrices etc.
</p>

<p>
Output of vertex processing stage might be called a <b>fragment</b>, or pixel depending on
used terminology. These are candidates to be visualized in the final image. Not all of
them ends up on the image because we do some processing to eliminate unneeded ones. 
For example, one fragment might lie behind the other and may represent something that
is not visible in the scene in the first place, due to being obscured by another object.
These will be, of course, eliminated from the final digital image as well. For the
ones remaining, we calculate the color of the fragment. This stage of the graphics
pipeline is called <b>ligthing and shading</b>. This could, again, be implemented as many
substages on a real graphics pipeline. 
</p>

<p>
This is, of course, a crude way to look at graphics pipelines and we will give more
detail as we go along. Still, the output image for the above bunny might look something
like this.
</p>


<div id="org30d2928" class="figure">
<p><img src="./img/bunny_colored.jpg" alt="bunny_colored.jpg" />
</p>
<p><span class="figure-number">Figure 8: </span>A bunny after we performed shading and coloring</p>
</div>

<p>
Meshes are not the only way to approximate arbitrary curves and surfaces. There
are many methods in fact. Meshes are popular because modern GPUs can process
them very efficiently but in an advanced study of CG, we need to know many
other techniques. One such technique depends on <b>polynomial approximations</b>
and we will talk about it briefly here so that you can have an idea. 
</p>


<div id="org4ebe997" class="figure">
<p><img src="./img/bernstein.jpg" alt="bernstein.jpg" />
</p>
<p><span class="figure-number">Figure 9: </span>Bernstein polynomial approximating a parabola</p>
</div>

<p>
Above formula might seem remote at first, we will talk about it in detail later. 
For now, try to see the big picture. Here, we have three points \(P_1, P_2, P_3\).
These are the <b>control points</b> of our curve. Note that formula gives the point
\(P_1\) when \(t=0\) and \(P_3\) when \(t=1\). In between 0 and 1, we get a point on the
curve \(C\) for each \(t\) value. We store three points and evaluate these formulas
in as much detail as we want to approximate a smooth curve. This is again a
good way to discretize a continuous phenomenon. Bezier curves and surfaces, NURBS,
splines etc. methods all work with this basic principle. We'll also take a look
at those since they are used heavily in modeling.
</p>

<p>
In this introduction, we wanted to give an idea of what CG really is, what we
do, what are some mathematical techniques we'll be employing etc. This whirlwind
tour was meant to whet your apetite but also to make sure you are up-to-date
with mathematical prerequisites. We also require that you know C++ programming.
If you are satisfied with this chapter and nothing seems useless or esoteric,
you can follow with next chapter to start learning more. 
</p>
</div>
</div>

<div id="outline-container-org5677c25" class="outline-2">
<h2 id="org5677c25"><span class="section-number-2">2</span> Some Geometry for Computer Graphics</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org080ae90" class="outline-3">
<h3 id="org080ae90"><span class="section-number-3">2.1</span> Affine Spaces and Transformations</h3>
<div class="outline-text-3" id="text-2-1">
<p>
You know about vectors and that geometrical vectors correspond to directions. The
place we need to be careful arises when we also consider points. You might have
seen mathematics books where they simply defined points as ends of vectors. 
This might led you to think that only the concept of vector and vector space would
be enough. But, the fact that there are diffferent operations you can do with
points that you can't do with vectors and vice versa should indicate that we
sould define them seperately.
</p>

<p>
In real life, you can walk from one point to the other point. It doesn'really 
make sense to walk from one direction to the other. In mathematical terms, we
say translating a vector does not change the vector but you can translate points.
Translating means moving around by the way, or carrying around. 
</p>

<p>
On the other hand, the most fundamental thing you can do with a point is to
move from one to the other, on a straight line. If you subtract two points,
you can get a vector denoting the direction to go from one point to the other. 
But what does it mean to add two points? If you do component wise addition, you
are again treating points as vectors. Thus, it does not make sense to add two
points. What does it mean to add north pole to south pole anyways, in real life?
</p>


<div id="orgc10f26b" class="figure">
<p><img src="./img/ch2/vectors.jpg" alt="vectors.jpg" />  
</p>
<p><span class="figure-number">Figure 10: </span>Translating a vector does not make sense</p>
</div>

<p>
On the above figure, you can observe the idea why translating vectors does not
make sense. Why all of these vectors are the same? Because they all have the 
same coordinates, say \((3, 4)\). Their extend on each coordinate axes are the
same. This is because we agreed that we are going to specify coordinates in 
relation to the origin. In a way, origin plays a special role. 
</p>

<p>
Here is the idea behind the affine space. In an affine space, we have a vector
space whose origin we try to think of as not special. If origin is not special,
you can use any point as an origin. This means, there are many ways to write
the coordinates of a point, depending on the origin you chose. 
</p>


<div id="org909c495" class="figure">
<p><img src="./img/ch2/coordinates.jpg" alt="coordinates.jpg" />  
</p>
<p><span class="figure-number">Figure 11: </span>Coordinates of a point might differ on an affine space</p>
</div>

<p>
This brings to the idea of an <b>affine frame</b>. You can think of them as local 
coordinate systems that we carry around. 
</p>

<div class="definition">
<p>
<b>Affine frame</b> <br />
In an affine space, we describe any 
point \(P\) by first starting from some origin point \(T\), and then adding to it
a linear combination of vectors. These vectors are expressed using coordinates \(c_i\) 
and a basis of vectors.
</p>

<p>
\[P = T + \sum_i{c_i \vec e_i}\]
</p>

<p>
and the matrix
</p>

<p>
\[[\vec e_1 \quad \vec e_2 \quad \vec e_3 \quad T] = \vec f^T\]
</p>

<p>
is called an affine frame \(f\) wrt. point \(T\), denoted \(\vec f^T\).
\(c = (c_1, c_2, c_3, 1)\) denotes the coordinates of the point \(P\) on this
frame. We can write \(P = \vec f^T c\)
</p>

</div>

<p>
In order to specify a point using a frame, we use a coordinate 4-vector with 
four entries, with the last entry always being 1. To express a vector using an affine
frame, we use a coordinate vector with a 0 as the fourth coordinate (i.e., it is 
simply a sum of the basis vectors). The use of coordinate 4-vectors to represent our
geometry (as well as 4-by-4 matrices) will also come in handy  when we model the
behavior of a pinhole camera later.
</p>

<p>
Let's unroll the matrix denoting the frame we show above, namely
\([\vec e_1 \quad \vec e_2 \quad \vec e_3 \quad T] = \vec f^T\). 
</p>

\begin{bmatrix}
    1 & 0 & 0 & t_1 \\
    0 & 1 & 0 & t_2 \\
    0 & 0 & 1 & t_3 \\
    0 & 0 & 0 &  1  \\
\end{bmatrix}

<p>
is what we get. This would translate the origin point \((0, 0, 0, 1)\) to 
\((t_1, t_2, t_3, 1)\). Take a look at this for a while and think about it.
Remember we said points have forth coordinate 1 and vectors have fourth 
coordinate 0. With this, we are going to define affine transformation as
having the form
</p>

\begin{bmatrix}
    a & b & c & d \\
    e & f & g & h \\
    i & j & k & l \\
    0 & 0 & 0 & 1 \\
\end{bmatrix}

<p>
in the 3D space. 
</p>

<div class="remark">
<p>
In CG, we focus on 3D space, or 2D. 
</p>

</div>

<p>
Say we have a point \(P = \vec f^T c\). How we can apply an affine transformation
the this point? 
</p>

<p>
\[ 
\left[ \begin{array}{cc}
\vec e_1 & \vec e_2 & \vec e_3 & T 
\end{array} \right]
%
\left[ \begin{array}{cc}
    a & b & c & d \\
    e & f & g & h \\
    i & j & k & l \\
    0 & 0 & 0 & 1  
\end{array} \right]
%
\left[ \begin{array}{cc}
    c1  \\
    c2  \\
    c3  \\
    1
\end{array} \right] = P'
\]
</p>

<p>
As you can see, we write it as \(P = \vec f^T A c\). You can think of this in
two different ways. You can tell that by performing \(A c\), we find the new
coordinates of transformed point, ie. \(c'\) on the frame \(\vec f^T\) or you 
can think of it as finding the point that has coordinates \(c\) an a transformed
new frame \(\vec f^T A\). With these, we can now develop couple of useful
transformations.
</p>

<p>
Let's first pin down the translation transformation we have been talking
about. For a point with coordinates \((c_1, c_2, c_3, 1)\), if we translate it
with the amounts \((t_1, t_2, t_3, 0)\), ie. we are adding a vector to it, we
should get to the point \((c_1 + t_1, c_2 + t_2, c_3 + t_3, 1)\). A 4x4 matrix
that has this effect is easy to find. Here it is
</p>

<p>
\[
\left[ \begin{array}{cc}
    1 & 0 & 0 & t_1 \\
    0 & 1 & 0 & t_2 \\
    0 & 0 & 1 & t_3 \\
    0 & 0 & 0 &  1  \\
\end{array} \right] = T
\]
</p>

<p>
Also, we can still express our 3x3 linear transformations in this new 4x4
setting. We just embed the linear transformation to the upper-left 3x3
part of a 4x4 matrix. 
</p>

<p>
\[
\left[ \begin{array}{cc}
    a & b & c & 0   \\
    e & f & g & 0   \\
    i & j & k & 0   \\
    0 & 0 & 0 & 1   \\
\end{array} \right] = L
\]
</p>

<p>
Observe that we can decompose an affine transformation into its linear and 
translational parts. 
</p>

<p>
\[ 
\left[ \begin{array}{cc}
    i & t \\
    0 & 1  
\end{array} \right]
%
\left[ \begin{array}{cc}
    l & 0 \\
    0 & 1 
\end{array} \right] = A
\]
</p>

<p>
With all these in mind, we are now going to talk about couple of famous
linear and affine transformations. We will develop their 4x4 matrices.
You can see that I am skipping these parts fast in terms of math. We assumed
you had calculus background and linear transformations should be familiar
to you. I just explained what we mean by affine, on top of that knowledge.
</p>

<div class="remark">
<p>
Linear transformations preserve collinearity, parallelism and origin. Any
two vector belonging to the same linear subspace will be in the same linear 
subspace after the transformation. The only difference between an affine space
is that we try to forget that origin is special. Thus, affine transformations
do not preserve the origin. If \(\vec 0\) is in an affine space, it might not
be there after an affine transformation. 
</p>

</div>

<p>
Let's now start with rotations. These are linear transformations.
</p>
</div>
</div>
</div>

<div id="outline-container-org5d9fd3d" class="outline-2">
<h2 id="org5d9fd3d"><span class="section-number-2">3</span> OpenGL Graphics Pipeline</h2>
</div>


<div id="outline-container-orga86eb85" class="outline-2">
<h2 id="orga86eb85"><span class="section-number-2">4</span> A Sample OpenGL Program</h2>
</div>

<div id="outline-container-org6cbc86f" class="outline-2">
<h2 id="org6cbc86f"><span class="section-number-2">5</span> OpenGL Data, aka Models</h2>
</div>

<div id="outline-container-org5884b14" class="outline-2">
<h2 id="org5884b14"><span class="section-number-2">6</span> OpenGL Algorithms, aka Shaders</h2>
</div>

<div id="outline-container-org13ecc27" class="outline-2">
<h2 id="org13ecc27"><span class="section-number-2">7</span> Project | Deferred Rendering</h2>
</div>

<div id="outline-container-org17e6bf9" class="outline-2">
<h2 id="org17e6bf9"><span class="section-number-2">8</span> A Bag of Advanced Rendering Techniques</h2>
</div>

<div id="outline-container-orgb485e7e" class="outline-2">
<h2 id="orgb485e7e"><span class="section-number-2">9</span> Rendering Equation</h2>
</div>

<div id="outline-container-org4b9799a" class="outline-2">
<h2 id="org4b9799a"><span class="section-number-2">10</span> Ray Tracing I</h2>
</div>

<div id="outline-container-orgfdccf86" class="outline-2">
<h2 id="orgfdccf86"><span class="section-number-2">11</span> Ray Tracing II</h2>
</div>

<div id="outline-container-org2d0d3c8" class="outline-2">
<h2 id="org2d0d3c8"><span class="section-number-2">12</span> Ray Tracing III</h2>
</div>
</div>
</body>
</html>
